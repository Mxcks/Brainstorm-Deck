# ============================================================================
# VISUAL CANVAS TOOL - STATE MANAGEMENT DETAILED SPECIFICATION
# ============================================================================
# Purpose: Comprehensive state structure, updates, persistence, and synchronization
# Created: 2025-09-30
# Version: 1.0.0
# ============================================================================

# ============================================================================
# SECTION 1: COMPLETE STATE STRUCTURE
# ============================================================================

state_structure:
  app_level_state:
    location: "App.tsx"
    description: "Global application state"
    
    state_items:
      - name: "currentProject"
        type: "Project | null"
        initial_value: "null"
        persistence: "localStorage key: 'currentProjectId'"
        description: "Currently selected project"
        
      - name: "projects"
        type: "Project[]"
        initial_value: "[]"
        persistence: "localStorage key: 'projects'"
        description: "All user projects"
        
      - name: "sidebarCollapsed"
        type: "boolean"
        initial_value: "false"
        persistence: "localStorage key: 'sidebarCollapsed'"
        description: "Whether left sidebar is collapsed"
        
      - name: "activeView"
        type: "'canvas' | 'library' | 'settings'"
        initial_value: "'canvas'"
        persistence: "sessionStorage key: 'activeView'"
        description: "Currently active view"
        
      - name: "creatorOpen"
        type: "boolean"
        initial_value: "false"
        persistence: "none (ephemeral)"
        description: "Whether component creator modal is open"
        
      - name: "selectedComponentId"
        type: "string | null"
        initial_value: "null"
        persistence: "none (ephemeral)"
        description: "ID of currently selected component on canvas"
        
  project_state_structure:
    type_definition: |
      interface Project {
        id: string;
        name: string;
        createdAt: string;
        updatedAt: string;
        canvasState: CanvasState;
        components: UIComponent[];
      }
      
      interface CanvasState {
        viewport: {
          x: number;
          y: number;
          zoom: number;
        };
        gridVisible: boolean;
        snapToGrid: boolean;
        gridSize: number;
      }
      
      interface UIComponent {
        id: string;
        type: 'button' | 'input' | 'text' | 'container' | 'image';
        position: { x: number; y: number };
        size: { width: number; height: number };
        properties: ComponentProperties;
      }
      
      interface ComponentProperties {
        // Visual properties
        backgroundColor?: string;
        textColor?: string;
        borderColor?: string;
        borderWidth?: number;
        borderRadius?: number;
        fontSize?: number;
        fontWeight?: number;
        padding?: { top: number; right: number; bottom: number; left: number };
        margin?: { top: number; right: number; bottom: number; left: number };
        
        // Content properties
        text?: string;
        placeholder?: string;
        
        // Behavior properties
        disabled?: boolean;
        required?: boolean;
      }

# ============================================================================
# SECTION 2: STATE INITIALIZATION
# ============================================================================

state_initialization:
  on_app_mount:
    description: "Initialize state when app first loads"
    
    sequence:
      - step: 1
        action: "Load persisted state from localStorage"
        code: |
          useEffect(() => {
            const loadState = async () => {
              // Load projects
              const savedProjects = localStorage.getItem('projects');
              if (savedProjects) {
                setProjects(JSON.parse(savedProjects));
              }
              
              // Load current project ID
              const currentProjectId = localStorage.getItem('currentProjectId');
              if (currentProjectId && savedProjects) {
                const projects = JSON.parse(savedProjects);
                const project = projects.find(p => p.id === currentProjectId);
                setCurrentProject(project || null);
              }
              
              // Load sidebar state
              const sidebarState = localStorage.getItem('sidebarCollapsed');
              if (sidebarState) {
                setSidebarCollapsed(JSON.parse(sidebarState));
              }
              
              // Load active view (from sessionStorage)
              const activeView = sessionStorage.getItem('activeView');
              if (activeView) {
                setActiveView(activeView as 'canvas' | 'library' | 'settings');
              }
            };
            
            loadState();
          }, []);
          
      - step: 2
        action: "Handle missing or corrupted data"
        scenarios:
          - scenario: "No projects found"
            action: "Show welcome screen, prompt to create first project"
            
          - scenario: "Current project ID invalid"
            action: "Clear currentProjectId, set to null"
            
          - scenario: "Corrupted project data"
            action: "Try to recover, or remove corrupted project"
            
  default_values:
    description: "Default values for new projects"
    
    new_project_defaults:
      canvasState:
        viewport: { x: 0, y: 0, zoom: 1 }
        gridVisible: true
        snapToGrid: false
        gridSize: 20
      components: []
      
    new_component_defaults:
      button:
        size: { width: 120, height: 40 }
        properties:
          backgroundColor: "#7c9885"
          textColor: "#ffffff"
          borderRadius: 6
          fontSize: 14
          fontWeight: 500
          text: "Button"
          
      input:
        size: { width: 200, height: 40 }
        properties:
          backgroundColor: "#ffffff"
          textColor: "#000000"
          borderColor: "#30363d"
          borderWidth: 1
          borderRadius: 4
          fontSize: 14
          placeholder: "Enter text..."

# ============================================================================
# SECTION 3: STATE UPDATE PATTERNS
# ============================================================================

state_update_patterns:
  simple_updates:
    description: "Direct state updates"
    
    use_cases:
      - use_case: "Toggle sidebar"
        trigger: "User clicks collapse button"
        update: |
          const handleToggleSidebar = () => {
            setSidebarCollapsed(prev => !prev);
          };
        persistence: "Auto-saved to localStorage via useEffect"
        
      - use_case: "Switch view"
        trigger: "User clicks navigation button"
        update: |
          const handleViewChange = (view: 'canvas' | 'library' | 'settings') => {
            setActiveView(view);
          };
        persistence: "Auto-saved to sessionStorage via useEffect"
        
  complex_updates:
    description: "Updates involving multiple state items"
    
    use_cases:
      - use_case: "Create new project"
        trigger: "User submits new project form"
        updates:
          - "Add project to projects array"
          - "Set as current project"
          - "Save to localStorage"
        implementation: |
          const handleCreateProject = (name: string) => {
            const newProject: Project = {
              id: generateId(),
              name,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              canvasState: {
                viewport: { x: 0, y: 0, zoom: 1 },
                gridVisible: true,
                snapToGrid: false,
                gridSize: 20
              },
              components: []
            };
            
            setProjects(prev => [...prev, newProject]);
            setCurrentProject(newProject);
          };
        side_effects:
          - "Projects array persisted to localStorage"
          - "Current project ID persisted to localStorage"
          - "Canvas re-renders with new project"
          
      - use_case: "Delete project"
        trigger: "User confirms project deletion"
        updates:
          - "Remove project from projects array"
          - "If deleted project is current, set current to null"
          - "Save to localStorage"
        implementation: |
          const handleDeleteProject = (projectId: string) => {
            setProjects(prev => prev.filter(p => p.id !== projectId));
            
            if (currentProject?.id === projectId) {
              setCurrentProject(null);
            }
          };
        side_effects:
          - "Projects array persisted to localStorage"
          - "Current project ID cleared if deleted"
          - "Canvas shows welcome screen if no project"
          
  nested_updates:
    description: "Updates to nested state objects"
    
    use_cases:
      - use_case: "Update component position"
        trigger: "User drags component on canvas"
        nested_path: "currentProject.components[i].position"
        implementation: |
          const handleComponentMove = (componentId: string, newPosition: { x: number; y: number }) => {
            setCurrentProject(prev => {
              if (!prev) return prev;
              
              return {
                ...prev,
                updatedAt: new Date().toISOString(),
                components: prev.components.map(comp =>
                  comp.id === componentId
                    ? { ...comp, position: newPosition }
                    : comp
                )
              };
            });
          };
        best_practice: "Always create new objects, never mutate"
        
      - use_case: "Update viewport"
        trigger: "User pans or zooms canvas"
        nested_path: "currentProject.canvasState.viewport"
        implementation: |
          const handleViewportChange = (viewport: { x: number; y: number; zoom: number }) => {
            setCurrentProject(prev => {
              if (!prev) return prev;
              
              return {
                ...prev,
                canvasState: {
                  ...prev.canvasState,
                  viewport
                }
              };
            });
          };
        optimization: "Debounce updates to reduce re-renders"
        
  optimistic_updates:
    description: "Update UI immediately, sync with storage later"
    
    use_cases:
      - use_case: "Component drag"
        trigger: "User drags component"
        flow: |
          1. Update local state immediately (optimistic)
          2. Component moves on screen instantly
          3. Debounced save to localStorage (500ms)
          4. If save fails, revert (rare with localStorage)
        implementation: |
          const handleComponentMove = (componentId: string, newPosition: { x: number; y: number }) => {
            // Optimistic update
            setCurrentProject(prev => {
              if (!prev) return prev;
              return {
                ...prev,
                components: prev.components.map(comp =>
                  comp.id === componentId ? { ...comp, position: newPosition } : comp
                )
              };
            });
            
            // Debounced save
            debouncedSave(currentProject);
          };
        benefits:
          - "Instant UI feedback"
          - "Smooth drag experience"
          - "Reduced save operations"

# ============================================================================
# SECTION 4: STATE PERSISTENCE
# ============================================================================

state_persistence:
  localStorage_strategy:
    description: "Persist state to localStorage"
    
    what_to_persist:
      - state: "projects"
        key: "visual-canvas-tool:projects"
        when: "Whenever projects array changes"
        
      - state: "currentProjectId"
        key: "visual-canvas-tool:currentProjectId"
        when: "Whenever current project changes"
        
      - state: "sidebarCollapsed"
        key: "visual-canvas-tool:sidebarCollapsed"
        when: "Whenever sidebar state changes"
        
    what_not_to_persist:
      - state: "creatorOpen"
        reason: "Modal should not reopen on refresh"
        
      - state: "selectedComponentId"
        reason: "Selection should not persist across sessions"
        
    implementation:
      auto_save_effect: |
        // Auto-save projects whenever they change
        useEffect(() => {
          if (projects.length > 0) {
            localStorage.setItem('visual-canvas-tool:projects', JSON.stringify(projects));
          }
        }, [projects]);
        
        // Auto-save current project ID
        useEffect(() => {
          if (currentProject) {
            localStorage.setItem('visual-canvas-tool:currentProjectId', currentProject.id);
          } else {
            localStorage.removeItem('visual-canvas-tool:currentProjectId');
          }
        }, [currentProject]);
        
      debounced_save: |
        // Debounce expensive saves (e.g., viewport changes)
        const debouncedSaveProject = useCallback(
          debounce((project: Project) => {
            const projects = JSON.parse(localStorage.getItem('visual-canvas-tool:projects') || '[]');
            const updatedProjects = projects.map(p => p.id === project.id ? project : p);
            localStorage.setItem('visual-canvas-tool:projects', JSON.stringify(updatedProjects));
          }, 500),
          []
        );
        
  sessionStorage_strategy:
    description: "Persist state to sessionStorage (cleared on tab close)"
    
    what_to_persist:
      - state: "activeView"
        key: "visual-canvas-tool:activeView"
        reason: "Preserve view within session, but reset on new session"
        
  future_database_strategy:
    description: "Future migration to The Know Database"
    
    phase_2_plan:
      - step: 1
        action: "Create DataService abstraction layer"
        reason: "Decouple storage from components"
        
      - step: 2
        action: "Implement DataService with localStorage"
        reason: "Current implementation"
        
      - step: 3
        action: "Add DataService implementation with The Know Database"
        reason: "Future implementation"
        
      - step: 4
        action: "Switch implementation via config"
        reason: "Easy migration"
        
    benefits:
      - "Multi-device sync"
      - "Backup and restore"
      - "Version history"
      - "Collaboration features"

# ============================================================================
# SECTION 5: STATE SYNCHRONIZATION
# ============================================================================

state_synchronization:
  parent_child_sync:
    description: "Keep parent and child state in sync"
    
    use_cases:
      - use_case: "Project updates from Canvas"
        flow: "Canvas → App (via callback) → Canvas (via props)"
        pattern: "Controlled component"
        implementation: |
          // App (parent)
          const [currentProject, setCurrentProject] = useState<Project | null>(null);
          
          const handleProjectUpdate = (updates: Partial<Project>) => {
            setCurrentProject(prev => prev ? { ...prev, ...updates } : null);
          };
          
          <Canvas 
            project={currentProject}
            onProjectUpdate={handleProjectUpdate}
          />
          
          // Canvas (child)
          const handleComponentMove = (componentId: string, position: { x: number; y: number }) => {
            const updatedProject = {
              ...project,
              components: project.components.map(c =>
                c.id === componentId ? { ...c, position } : c
              )
            };
            onProjectUpdate(updatedProject);
          };
          
  multi_tab_sync:
    description: "Sync state across multiple browser tabs"
    status: "Future enhancement"
    
    implementation:
      storage_event: |
        // Listen for localStorage changes from other tabs
        useEffect(() => {
          const handleStorageChange = (e: StorageEvent) => {
            if (e.key === 'visual-canvas-tool:projects' && e.newValue) {
              setProjects(JSON.parse(e.newValue));
            }
            
            if (e.key === 'visual-canvas-tool:currentProjectId' && e.newValue) {
              const projectId = e.newValue;
              const project = projects.find(p => p.id === projectId);
              setCurrentProject(project || null);
            }
          };
          
          window.addEventListener('storage', handleStorageChange);
          return () => window.removeEventListener('storage', handleStorageChange);
        }, [projects]);
        
    conflicts:
      scenario: "User edits same project in two tabs"
      resolution: "Last write wins (simple), or conflict detection (complex)"

# ============================================================================
# SECTION 6: STATE VALIDATION
# ============================================================================

state_validation:
  on_load:
    description: "Validate state when loading from storage"
    
    validations:
      - validation: "Projects array is valid"
        checks:
          - "Is array"
          - "Each project has required fields (id, name, createdAt, etc.)"
          - "Each project.components is array"
          - "Each component has required fields"
        on_failure: "Remove invalid projects, log error"
        
      - validation: "Current project ID exists"
        checks:
          - "ID is string"
          - "Project with ID exists in projects array"
        on_failure: "Set currentProject to null"
        
    implementation: |
      const validateProjects = (projects: any[]): Project[] => {
        return projects.filter(project => {
          if (!project.id || !project.name || !project.createdAt) {
            console.error('Invalid project:', project);
            return false;
          }
          
          if (!Array.isArray(project.components)) {
            console.error('Invalid components:', project);
            return false;
          }
          
          return true;
        });
      };
      
  on_update:
    description: "Validate state before updating"
    
    validations:
      - validation: "Component position is valid"
        checks:
          - "x and y are numbers"
          - "x and y are finite"
        on_failure: "Reject update, keep previous position"
        
      - validation: "Component size is valid"
        checks:
          - "width and height are numbers"
          - "width and height are positive"
          - "width and height are finite"
        on_failure: "Reject update, keep previous size"

# ============================================================================
# SECTION 7: STATE DEBUGGING
# ============================================================================

state_debugging:
  dev_tools:
    description: "Tools for debugging state"
    
    tools:
      - tool: "React DevTools"
        usage: "Inspect component state and props"
        
      - tool: "Redux DevTools"
        usage: "Time-travel debugging (if using Redux)"
        status: "Not currently using Redux"
        
      - tool: "Console logging"
        usage: "Log state changes in development"
        implementation: |
          useEffect(() => {
            if (process.env.NODE_ENV === 'development') {
              console.log('State changed:', { currentProject, projects, sidebarCollapsed, activeView });
            }
          }, [currentProject, projects, sidebarCollapsed, activeView]);
          
  state_snapshots:
    description: "Save state snapshots for debugging"
    
    implementation: |
      // Save state snapshot to file
      const saveStateSnapshot = () => {
        const state = {
          currentProject,
          projects,
          sidebarCollapsed,
          activeView,
          timestamp: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `state-snapshot-${Date.now()}.json`;
        a.click();
      };

# ============================================================================
# SECTION 8: STATE MIGRATION
# ============================================================================

state_migration:
  version_management:
    description: "Handle state structure changes across versions"
    
    strategy:
      - step: 1
        action: "Add version field to state"
        implementation: |
          interface Project {
            version: number; // Add this
            id: string;
            name: string;
            // ...
          }
          
      - step: 2
        action: "Check version on load"
        implementation: |
          const loadProjects = () => {
            const saved = localStorage.getItem('visual-canvas-tool:projects');
            if (!saved) return [];
            
            const projects = JSON.parse(saved);
            return projects.map(migrateProject);
          };
          
      - step: 3
        action: "Migrate old versions"
        implementation: |
          const migrateProject = (project: any): Project => {
            // No version = v1
            if (!project.version) {
              return migrateV1ToV2(project);
            }
            
            // Already current version
            if (project.version === CURRENT_VERSION) {
              return project;
            }
            
            // Migrate through versions
            let migrated = project;
            if (migrated.version === 1) migrated = migrateV1ToV2(migrated);
            if (migrated.version === 2) migrated = migrateV2ToV3(migrated);
            return migrated;
          };
          
    example_migration:
      from_version: 1
      to_version: 2
      changes: "Add canvasState.snapToGrid field"
      implementation: |
        const migrateV1ToV2 = (project: any): Project => {
          return {
            ...project,
            version: 2,
            canvasState: {
              ...project.canvasState,
              snapToGrid: false // Add new field with default
            }
          };
        };

